package com.google.closure.plugin.common;

import java.io.Serializable;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.Collection;

import com.google.common.base.Function;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;

/**
 * Options for a compiler.
 */
@SuppressWarnings("serial")  // is abstract
public abstract class Options
implements Cloneable, Serializable, StructurallyComparable, Identifiable {

  /**
   * If not supplied, autogenerated.
   * <p>
   * Compilers that may be run multiple times with different options may use
   * the ID to disambiguate outputs.
   */
  public String id;

  boolean wasIdImplied;

  /**
   * An ID that must be unique among a bundle of instances of the same kind used
   * in a compilation.
   * <p>
   * @throws NullPointerException if this has not been disambiguated as per
   *     {@link OptionsUtils#disambiguateIds}.
   */
  @Override
  public final String getId() {
    return Preconditions.checkNotNull(id);
  }

  /**
   * True iff the ID was set automatically to avoid ambiguity.
   */
  public boolean wasIdImplied() {
    return this.wasIdImplied;
  }

  /**
   * Called after plexus configurations to create defaults for fields that were
   * not supplied by the plexus configurator.
   */
  protected abstract void createLazyDefaults();

  @SuppressWarnings("static-method")
  protected ImmutableList<? extends Options> getSubOptions() {
    return ImmutableList.of();
  }

  /**
   * May be overridden to store the asploded version of {@link #getSubOptions}.
   */
  protected void setSubOptions(
      @SuppressWarnings("unused")
      ImmutableList<? extends Options> preparedSubOptions) {
    throw new UnsupportedOperationException();
  }

  /**
   * A best-effort copy since options have public immutable fields so that the
   * plexus configurator can muck with them.
   */
  @Override
  public Options clone() throws CloneNotSupportedException {
    try {
      Class<? extends Options> cl = getClass();
      Constructor<? extends Options> ctor = cl.getConstructor();
      Options clone = cl.cast(ctor.newInstance());
      for (Field f : cl.getDeclaredFields()) {
        if (Modifier.isStatic(f.getModifiers())) { continue; }
        Class<?> ct = f.getType();
        if (Collection.class.isAssignableFrom(ct)) {
          copyAllInto(f, clone, this);
        } else {
          f.set(clone, f.get(this));
        }
      }
      return clone;
    } catch (ReflectiveOperationException ex) {
      throw (CloneNotSupportedException)
          new CloneNotSupportedException().initCause(ex);
    }
  }

  private static <T> void copyAllInto(
      final Field f, Object destObj, Object srcObj) {
    Preconditions.checkState(
        destObj.getClass() == srcObj.getClass()
        && destObj.getClass().getTypeParameters().length == 0);
    Function<Object, Collection<T>> getFieldValue =
        new Function<Object, Collection<T>>() {
          // This is actually type-safe because the same field is used for both
          // and the objects have exactly the same unparameterized concrete
          // class.
          @SuppressWarnings("unchecked")
          @Override
          public Collection<T> apply(Object o) {
            try {
              f.setAccessible(true);
              return (Collection<T>) f.get(o);
            } catch (IllegalAccessException ex) {
              throw (AssertionError) new AssertionError("setAccessible")
                  .initCause(ex);
            }
          }
        };
    Collection<T> dest = getFieldValue.apply(destObj);
    Collection<T> src = getFieldValue.apply(srcObj);
    dest.clear();
    dest.addAll(src);
  }

  @Override
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + (wasIdImplied ? 1231 : 1237);
    return result;
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) {
      return true;
    }
    if (obj == null) {
      return false;
    }
    if (getClass() != obj.getClass()) {
      return false;
    }
    Options other = (Options) obj;
    if (id == null) {
      if (other.id != null) {
        return false;
      }
    } else if (!id.equals(other.id)) {
      return false;
    }
    if (wasIdImplied != other.wasIdImplied) {
      return false;
    }
    return true;
  }
}
