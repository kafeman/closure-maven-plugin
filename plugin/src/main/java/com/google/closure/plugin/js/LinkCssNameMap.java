package com.google.closure.plugin.js;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;

import org.apache.maven.plugin.MojoExecutionException;

import com.google.closure.plugin.plan.JoinNodes;
import com.google.closure.plugin.plan.PlanContext;
import com.google.closure.plugin.plan.PlanGraphNode;
import com.google.common.base.Charsets;
import com.google.common.collect.ImmutableList;
import com.google.common.css.OutputRenamingMapFormat;
import com.google.common.io.Files;

/**
 * Outputs the CSS Name map as a JavaScript source.
 */
final class LinkCssNameMap extends PlanGraphNode<LinkCssNameMap.SV> {
  LinkCssNameMap(PlanContext context) {
    super(context);
  }

  private boolean changed = false;

  File getJsRenameMap() {
    return new File(context.genfilesDirs.jsGenfiles, "css-rename-map.js");
  }


  @Override
  protected void preExecute(Iterable<? extends PlanGraphNode<?>> preceders) {
    // Nop
  }

  @Override
  protected void filterUpdates() throws IOException, MojoExecutionException {
    changed = !context.buildContext.isIncremental()
        || context.buildContext.hasDelta(getJsRenameMap());
  }

  @Override
  protected Iterable<? extends File> changedOutputFiles() {
    return changed
        ? ImmutableList.of(getJsRenameMap())
        : ImmutableList.<File>of();
  }

  @Override
  protected void process() throws IOException, MojoExecutionException {
    if (!changed) { return; }
    File jsRenameMap = getJsRenameMap();

    Files.createParentDirs(jsRenameMap);
    try (OutputStream out = new FileOutputStream(jsRenameMap)) {
      try (Writer writer = new OutputStreamWriter(out, Charsets.UTF_8)) {
        writer.write("// Autogenerated by ");
        writer.write(getClass().getName());
        writer.write("\n");

        OutputRenamingMapFormat.CLOSURE_COMPILED_BY_WHOLE.writeRenamingMap(
            context.substitutionMapProvider.get().getMappings(),
            writer);
        // TODO: freeze the renaming map so no new entries can be added.
      }
    } catch (IOException ex) {
      throw new MojoExecutionException(
          "Failed to link CSS rename map to JS", ex);
    }
  }

  @Override
  protected SV getStateVector() {
    return new SV(this);
  }


  static final class SV implements PlanGraphNode.StateVector {

    private static final long serialVersionUID = 1L;

    final boolean changed;

    @SuppressWarnings("synthetic-access")
    SV(LinkCssNameMap node) {
      this.changed = node.changed;
    }

    @Override
    @SuppressWarnings("synthetic-access")
    public PlanGraphNode<?> reconstitute(PlanContext c, JoinNodes jn) {
      LinkCssNameMap node = new LinkCssNameMap(c);
      node.changed = changed;
      return node;
    }
  }
}
