package com.google.closure.plugin.genjava;

import java.io.File;
import java.io.IOException;
import java.util.Collection;
import java.util.Map;

import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.logging.Log;

import com.google.closure.plugin.common.Ingredients.DirScanFileSetIngredient;
import com.google.closure.plugin.common.Ingredients.FileIngredient;
import com.google.closure.plugin.common.Ingredients.PathValue;
import com.google.closure.plugin.common.Ingredients.StringValue;
import com.google.closure.plugin.plan.PlanKey;
import com.google.closure.plugin.plan.Step;
import com.google.closure.plugin.plan.StepSource;
import com.google.common.base.Charsets;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Maps;
import com.google.common.collect.Multimap;
import com.google.common.collect.Sets;
import com.google.common.collect.TreeMultimap;
import com.google.common.io.Files;

final class GenJavaSymbols extends Step {

  GenJavaSymbols(
      DirScanFileSetIngredient outputFiles,
      PathValue webFilesJava, StringValue packageName) {
    super(
        PlanKey.builder("gen-java-symbols")
            .addInp(outputFiles, webFilesJava, packageName)
            .build(),
        ImmutableList.of(outputFiles, webFilesJava, packageName),
        StepSource.ALL_COMPILED,
        Sets.immutableEnumSet(StepSource.JAVA_GENERATED));
  }

  @Override
  public void execute(Log log) throws MojoExecutionException {
    DirScanFileSetIngredient outputFiles =
        (DirScanFileSetIngredient) inputs.get(0);
    PathValue webFilesJava = (PathValue) inputs.get(1);
    StringValue packageName = (StringValue) inputs.get(2);

    Multimap<String, File> constantNameToRelPaths = TreeMultimap.create();
    for (FileIngredient fi : outputFiles.sources()) {
      File relativePath = fi.source.relativePath;
      String name = bestEffortIdentifier(relativePath);
      constantNameToRelPaths.put(name, relativePath);
    }

    Map<String, String> uniqConstantNameToUriPath = Maps.newLinkedHashMap();
    for (Map.Entry<String, Collection<File>> e
         : constantNameToRelPaths.asMap().entrySet()) {
      String identUnuniq = e.getKey();
      Collection<File> files = e.getValue();
      // If there's one, try to use identUnuniq as-is.
      int index = files.size() == 1 ? -1 : 0;
      for (File relPath : files) {
        String path = relPath.getPath();
        if (File.separatorChar != '/') {
          path = path.replace(File.separatorChar, '/');
        }
        // rel-paths are relative, but we want something
        // that can be appended to a base directory to give an absolute URI
        // path, so start with a "/".
        Preconditions.checkState(!path.startsWith("/"));
        path = "/" + path;
        String identUniq;
        do {
          identUniq = index == -1 ? identUnuniq : identUnuniq + "$" + index;
          ++index;
        } while (uniqConstantNameToUriPath.containsKey(identUniq));
        Object prev = uniqConstantNameToUriPath.put(identUniq, path);
        Preconditions.checkState(prev == null);
      }
    }

    String cName = webFilesJava.value.getName().replaceFirst("[.]java$", "");
    Preconditions.checkState(cName.indexOf('.') < 0);

    JavaWriter jw = new JavaWriter();
    jw.appendCode("// Generated by ").appendCode(getClass().getName()).nl();
    jw.appendCode("package ").appendCode(packageName.value).appendCode(";\n");
    jw.nl();
    jw.appendCode("/**\n");
    jw.appendCode(" * Symbolic constants for compiled web resources.\n");
    jw.appendCode(" */\n");
    jw.appendCode("public final class ").appendCode(cName).appendCode(" {\n");
    jw.appendCode(  "private ").appendCode(cName).appendCode("() {\n");
    jw.appendCode(    "// Not instantiable.\n");
    jw.appendCode(  "}\n");
    for (Map.Entry<String, String> e : uniqConstantNameToUriPath.entrySet()) {
      String ident = e.getKey();
      String uriPath = e.getValue();
      String ext = Files.getFileExtension(uriPath);
      jw.nl();
      jw.appendCode("/** Web path to a compiled {@code ")
        .appendCommentPart(ext).appendCode("} file. */\n");
      jw.appendCode("public static final String ").appendCode(ident)
        .appendCode(" = ").appendStringLiteral(uriPath).appendCode(";\n");
    }
    jw.appendCode("}\n");

    webFilesJava.value.getParentFile().mkdirs();
    try {
      Files.write(jw.toJava(), webFilesJava.value, Charsets.UTF_8);
    } catch (IOException ex) {
      throw new MojoExecutionException("Failed to write symbols file", ex);
    }
  }

  @Override
  public void skip(Log log) throws MojoExecutionException {
    // Done.
  }

  @Override
  public ImmutableList<Step> extraSteps(Log log) throws MojoExecutionException {
    return ImmutableList.of();
  }


  private static String bestEffortIdentifier(File f) {
    StringBuilder sb = new StringBuilder();
    appendBestEffortIdentifier(f, sb);
    if (sb.length() == 0
        || !Character.isJavaIdentifierStart(sb.codePointAt(0))) {
      sb.insert(0, '$');
    }
    return sb.toString();
  }

  private static void appendBestEffortIdentifier(File f, StringBuilder sb) {
    File parent = f.getParentFile();
    if (parent != null) {
      appendBestEffortIdentifier(parent, sb);
      sb.append('_');
    }
    String name = f.getName();
    int n = name.length();
    for (int i = 0, cp; i < n; i += Character.charCount(cp)) {
      // By upper-casing we move the identifier out of the space of reserved
      // keywords and follow the Java naming convention for constants.
      cp = Character.toUpperCase(name.codePointAt(i));
      if (Character.isJavaIdentifierPart(cp)) {
        sb.appendCodePoint(cp);
      } else {
        sb.append('_');
      }
    }
  }
}
